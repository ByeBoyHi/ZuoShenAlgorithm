package Chapter3_Algorithm.U6_DP;public class th2_CoinsMin {    /*        一个正数数组：里面每一个值代表"一枚"硬币的面值，有可能有"重复值"。        给一个数值，求组成这个数值，最少用多少硬币。     */    public static void main(String[] args) {        int len = 10;        int max = 10;        int testTime = 10000;        for (int i = 0; i < testTime; i++) {            int[] arr = generateRandomArray(len, max);            int aim = (int) (Math.random() * 3 * max) + max;            if (minCoins2(arr, aim) != minCoins3(arr, aim)                    && minCoins1(arr, aim) != minCoins2(arr, aim)) {                System.out.println("oooops!");                break;            }        }    }    // 递归    public static int minCoins1(int[] arr, int aim) {        return process(arr, 0, aim);    }    /**     * 在硬币数组上，对于给定数值，要求返回使用最少的硬币数把这个数值拼凑出来     *     * @param arr   硬币数组     * @param index 当前所在的硬币位置     * @param rest  还剩下的匹配数组     * @return 返回最少硬币数     * -1代表无效解，我们对于-1要特殊处理。     * 不能用0作为无效解，因为不用硬币也可以是最优解。     */    public static int process(int[] arr, int index, int rest) {        if (rest == 0) {  // 当前不用硬币，返回0            return 0;        }        if (rest < 0 || index == arr.length) {  // 超值了或者硬币用完了，返回-1            return -1;        }        int use = process(arr, index + 1, rest - arr[index]);        int noUse = process(arr, index + 1, rest);//         消除-1的影响        if (use == -1 && noUse == -1) {  // 两个都是无效解            return -1;        } else {  // 里面至少有一个不是-1            // 返回不是-1的那个值            if (use == -1) {                return noUse;            }            if (noUse == -1) {                return use + 1;            }            // 都不是-1，返回最小值            return Math.min(use + 1, noUse);            // use+1表示当前硬币要使用，所以使用硬币数+1        }        // 用一个绝对不可能的极大值代替-1//        return Math.min(use + 1, noUse);    }    // 记忆化搜索    public static int minCoins2(int[] arr, int aim) {        // 两个可变参数        // index: 0->len        // aim: 0->aim        int[][] dp = new int[arr.length + 1][aim + 1];        for (int i = 0; i < dp.length; i++) {            for (int j = 0; j < dp[0].length; j++) {                dp[i][j] = -2;  // -1表示没算过 -2表示无效解            }        }        return process2(arr, 0, aim, dp);    }    /**     * 在硬币数组上，对于给定数值，要求返回使用最少的硬币数把这个数值拼凑出来     *     * @param arr   硬币数组     * @param index 当前所在的硬币位置     * @param rest  还剩下的匹配数组     * @param dp    记忆化缓存数组     * @return 返回最少硬币数     * -1代表无效解，我们对于-1要特殊处理。     * 不能用0作为无效解，因为不用硬币也可以是最优解。     */    public static int process2(int[] arr, int index, int rest, int[][] dp) {        // 无效区缓存，返回-1        if (rest < 0) {            return -1;        }        if (dp[index][rest] != -2) {            return dp[index][rest];        }        // 前两个判断的顺序不能换，因为当你用完的时候，可能rest也恰好等于0，这时候 rest=0 优先级更高        if (rest == 0) {  // 当前不用硬币，返回0            dp[index][rest] = 0;        } else if (index == arr.length) {  // 硬币用完            dp[index][rest] = -1;        } else {            int use = process2(arr, index + 1, rest - arr[index], dp);            int noUse = process2(arr, index + 1, rest, dp);            if (use == -1 && noUse == -1) {  // 两个都是无效解                dp[index][rest] = -1;            } else {  // 里面至少有一个不是-1                // 返回不是-1的那个值                if (use == -1) {                    dp[index][rest] = noUse;                } else if (noUse == -1) {                    dp[index][rest] = use + 1;                } else {                    // 都不是-1，返回最小值                    dp[index][rest] = Math.min(use + 1, noUse);                }            }        }        return dp[index][rest];    }    // DP    public static int minCoins3(int[] arr, int aim) {        int N = arr.length;        int[][] dp = new int[N + 1][aim + 1];        for (int i = 0; i <= N; i++) {            dp[i][0] = 0;        }        for (int j = 1; j <= aim; j++) {            dp[N][j] = -1;        }        // 因为中间的格子依赖于正下方的格子和正下方减去当前硬币值的格子        // 所以从最后一行的第一列开始更新，更新到右上角        for (int index = N - 1; index >= 0; index--) {            for (int rest = 1; rest <= aim; rest++) {                int use = -1;  // 可能越界，判断一下                int noUse = dp[index + 1][rest];                if (rest - arr[index] >= 0) { // 越界就是当前硬币值超过了我们的剩下数值                    use = dp[index][rest - arr[index]];                }                // 消除-1的影响                if (use == -1 && noUse == -1) {  // 两个都是无效解                    dp[index][rest] = -1;                } else {  // 里面至少有一个不是-1                    // 返回不是-1的那个值                    if (use == -1) {                        dp[index][rest] = noUse;                    } else if (noUse == -1) {                        dp[index][rest] = use + 1;                    } else {                        // 都不是-1，返回最小值                        dp[index][rest] = Math.min(use + 1, noUse);                        // use+1表示当前硬币要使用，所以使用硬币数+1                    }                }            }        }        return dp[0][aim];    }    // 对数器：for test    public static int[] generateRandomArray(int len, int max) {        int[] arr = new int[len];        for (int i = 0; i < len; i++) {            arr[i] = (int) (Math.random() * 3 * max) + 1;        }        return arr;    }    //---------------------------------------------------------------------    //---------------------------------------------------------------------    // 以下是方法数，和这次题解无关    public static int min1(int[] arr, int aim) {        return f(arr, 0, 0, aim);    }    /**     * 返回这个硬币数组能够组成aim的方法数的个数     *     * @param arr   硬币数组     * @param index 当前判断第几个硬币     * @param pre   在这个硬币之前，我们已经储备了多少数值     * @param aim   我们的目标值     * @return 组成aim的方法数     */    public static int f(int[] arr, int index, int pre, int aim) {        if (pre > aim) {  // 剪枝：已经超过了，就没必要往下尝试了            return 0;        }        if (index == arr.length) {  // 所有硬币都尝试过了            return pre == aim ? 1 : 0;        }        return f(arr, index + 1, pre, aim) +  // 取当前硬币                f(arr, index + 1, pre + arr[index], aim);  // 不取当前硬币    }}